# Linux进程间通信（IPC）

广义上讲，进程间通信(Inter-Process Communication, IPC)是指运行在不同进程(不论是否在同一台机器)中的若干线程间的数据交换。

从上面的定义可以得出两点：

- 参与通信的进程即可以运行在同一台机器上，也可以运行在各自的设备环境中(Remote Procedure Call Protocol, RPC)。如果进程是跨机器运行的，则通常是由网络连接在一起。
- 实现方式可以有多种多样。原则上，任何跨进程的数据交换都可以称为进程间通信。

## 常见的几种进程间通信方式

- 管道(Pipe)及有名管道（named pipe）
- 信号(Signal)
- 消息队列(Message Queue)
- 共享内存(Shared Memory)
- 信号量(Semaphore)
- 套接字(Socket)

## 管道(Pipe)及有名管道（named pipe）

管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

管道是Linux支持的最初Unix IPC形式之一，具有以下特点：

- 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；
- 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；
- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
- 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

## 信号(Signal)

信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；  

### 信号本质

信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。  
信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

信号是进程间通信机制中**唯一的异步通信机制**，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。

### 信号来源

信号事件的发生有两个来源：

- 硬件来源(比如我们按下了键盘或者其它硬件故障)；
- 软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。

## 消息队列(Message Queue)

消息队列（也叫做报文队列）能够克服早期unix通信机制的一些缺点。  
消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。  
对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。

目前主要有两种类型的消息队列：

- POSIX消息队列
- system V消息队列，系统V消息队列目前被大量使用。考虑到程序的可移植性，新开发的应用程序应尽量使用POSIX消息队列。

## 共享内存(Shared Memory)

使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。  
对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。

实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。因此，采用共享内存的通信方式效率是非常高的。

一般情况下，实现内存共享的步骤如下：

- 创建内存共享区
> 内存共享区存在于内核中

- 映射内存共享区
> 需要将内存共享区映射到进程的空间中才可以进一步操作

- 访问内存共享区

- 进程间通信
> 由于内存共享本身并没有提供同步机制，所遇参与通信的各个进程需要自己协商处理。

- 撤销内存映射区

- 删除内存共享区

## 信号量(Semaphore)

主要作为进程间以及同一进程不同线程之间的同步手段;

信号灯与其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。相当于内存中的标志，进程可以根据它判定是否能够访问某些共享资源，同时，进程也可以修改该标志。除了用于访问控制外，还可用于进程同步。

信号灯有以下两种类型：

- 二值信号灯：最简单的信号灯形式，信号灯的值只能取0或1，类似于互斥锁。
> 注：二值信号灯能够实现互斥锁的功能，但两者的关注内容不同。信号灯强调共享资源，只要共享资源可用，其他进程同样可以修改信号灯的值；互斥锁更强调进程，占用资源的进程使用完资源后，必须由进程本身来解锁。

- 计算信号灯：信号灯的值可以取任意非负值（当然受内核本身的约束）

## 套接字(Socket)

套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

一个套接口可以看作是进程间通信的端点（endpoint），每个套接口的名字都是唯一的（唯一的含义是不言而喻的），其他进程可以发现、连接并且与之通信。  
**通信域**用来说明套接口通信的协议，不同的通信域有不同的通信协议以及套接口的地址结构等等，因此，创建一个套接口时，要指明它的通信域。比较常见的是**unix域套接口**（采用套接口机制实现单机内的进程间通信）及**网际通信域**。

目前linux网络API是基于BSD套接口的，套接口可以说是网络编程中一个非常重要的概念。  
linux以文件的形式实现套接口，与套接口相应的文件属于sockfs特殊文件系统，创建一个套接口就是在sockfs中创建一个特殊文件，并建立起为实现套接口功能的相关数据结构。换句话说，对每一个新创建的BSD套接口，linux内核都将在sockfs特殊文件系统中创建一个新的inode。描述套接口的数据结构是socket。

### 表示套接口的数据结构struct socket

```c++
struct socket
{
  socket_state  state;     /* 指明套接口的连接状态，一个套接口的连接状态可以有以下几种套接口是空闲的，还没有进行相应的端口及地址的绑定；还没有连接；正在连接中；已经连接；正在解除连接。 */
  unsigned long    flags;
  struct proto_ops  ops;  /* 指明可对套接口进行的各种操作 */
  struct inode    inode;    /* 指向sockfs文件系统中的相应inode */
  struct fasync_struct  *fasync_list;  /* Asynchronous wake up list  */
  struct file    *file;          /* 指向sockfs文件系统中的相应文件  */
  struct sock    sk;  /* 任何协议族都有其特定的套接口特性，该域就指向特定协议族的套接口对象。 */
  wait_queue_head_t  wait;
  short      type;
  unsigned char    passcred;
};
```

两种角色：服务器与客户端
每种角色的大致流程如下：

服务器：

- Create socket - socket()
- Bind sockaddr - bind()
- Listen - listen()
- Wait & Accept
  - 一般在一个循环里边监听是否有新的连接 - accept()；然后可以读写了
  - 读 - recv()
  - 写 - send()
  - 关闭连接与客户端的连接 - close()
- 释放socket close()

客户端：

- Create socket - socket()
- Bind sockaddr - bind()
- 连接服务器 - accept()；然后可以读写了
  - 读 recv()
  - 写 send()
- 关闭连接 close()

> 注意，如果服务器与客户端在同一台主机上，则是跨进程通信。如果在不同的主机上，则变成了网络通信。

## Reference

- <http://blog.csdn.net/pcsxk/article/details/48970405>
- <https://www.ibm.com/developerworks/cn/linux/l-ipc/>
- <https://www.ibm.com/developerworks/cn/linux/l-ipc/part6/index.html>